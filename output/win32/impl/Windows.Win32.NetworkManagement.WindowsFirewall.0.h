// WARNING: Please don't edit this file. It was generated by C++/Win32 v0.0.0.1

#ifndef WIN32_Windows_Win32_NetworkManagement_WindowsFirewall_0_H
#define WIN32_Windows_Win32_NetworkManagement_WindowsFirewall_0_H
WIN32_EXPORT namespace win32::Windows::Win32::Foundation
{
    struct BOOL;
    struct PWSTR;
}
WIN32_EXPORT namespace win32::Windows::Win32::NetworkManagement::WindowsFirewall
{
#pragma region enums
    enum class ICS_TARGETTYPE : int32_t
    {
        ICSTT_NAME = 0,
        ICSTT_IPADDRESS = 1,
    };
    enum class INET_FIREWALL_AC_CHANGE_TYPE : int32_t
    {
        INET_FIREWALL_AC_CHANGE_INVALID = 0,
        INET_FIREWALL_AC_CHANGE_CREATE = 1,
        INET_FIREWALL_AC_CHANGE_DELETE = 2,
        INET_FIREWALL_AC_CHANGE_MAX = 3,
    };
    enum class INET_FIREWALL_AC_CREATION_TYPE : int32_t
    {
        INET_FIREWALL_AC_NONE = 0,
        INET_FIREWALL_AC_PACKAGE_ID_ONLY = 1,
        INET_FIREWALL_AC_BINARY = 2,
        INET_FIREWALL_AC_MAX = 4,
    };
    enum class NETCONMGR_ENUM_FLAGS : int32_t
    {
        NCME_DEFAULT = 0,
        NCME_HIDDEN = 1,
    };
    enum class NETCONUI_CONNECT_FLAGS : int32_t
    {
        NCUC_DEFAULT = 0,
        NCUC_NO_UI = 1,
        NCUC_ENABLE_DISABLE = 2,
    };
    enum class NETCON_CHARACTERISTIC_FLAGS : int32_t
    {
        NCCF_NONE = 0,
        NCCF_ALL_USERS = 1,
        NCCF_ALLOW_DUPLICATION = 2,
        NCCF_ALLOW_REMOVAL = 4,
        NCCF_ALLOW_RENAME = 8,
        NCCF_INCOMING_ONLY = 32,
        NCCF_OUTGOING_ONLY = 64,
        NCCF_BRANDED = 128,
        NCCF_SHARED = 256,
        NCCF_BRIDGED = 512,
        NCCF_FIREWALLED = 1024,
        NCCF_DEFAULT = 2048,
        NCCF_HOMENET_CAPABLE = 4096,
        NCCF_SHARED_PRIVATE = 8192,
        NCCF_QUARANTINED = 16384,
        NCCF_RESERVED = 32768,
        NCCF_HOSTED_NETWORK = 65536,
        NCCF_VIRTUAL_STATION = 131072,
        NCCF_WIFI_DIRECT = 262144,
        NCCF_BLUETOOTH_MASK = 983040,
        NCCF_LAN_MASK = 15728640,
    };
    enum class NETCON_MEDIATYPE : int32_t
    {
        NCM_NONE = 0,
        NCM_DIRECT = 1,
        NCM_ISDN = 2,
        NCM_LAN = 3,
        NCM_PHONE = 4,
        NCM_TUNNEL = 5,
        NCM_PPPOE = 6,
        NCM_BRIDGE = 7,
        NCM_SHAREDACCESSHOST_LAN = 8,
        NCM_SHAREDACCESSHOST_RAS = 9,
    };
    enum class NETCON_STATUS : int32_t
    {
        NCS_DISCONNECTED = 0,
        NCS_CONNECTING = 1,
        NCS_CONNECTED = 2,
        NCS_DISCONNECTING = 3,
        NCS_HARDWARE_NOT_PRESENT = 4,
        NCS_HARDWARE_DISABLED = 5,
        NCS_HARDWARE_MALFUNCTION = 6,
        NCS_MEDIA_DISCONNECTED = 7,
        NCS_AUTHENTICATING = 8,
        NCS_AUTHENTICATION_SUCCEEDED = 9,
        NCS_AUTHENTICATION_FAILED = 10,
        NCS_INVALID_ADDRESS = 11,
        NCS_CREDENTIALS_REQUIRED = 12,
        NCS_ACTION_REQUIRED = 13,
        NCS_ACTION_REQUIRED_RETRY = 14,
        NCS_CONNECT_FAILED = 15,
    };
    enum class NETCON_TYPE : int32_t
    {
        NCT_DIRECT_CONNECT = 0,
        NCT_INBOUND = 1,
        NCT_INTERNET = 2,
        NCT_LAN = 3,
        NCT_PHONE = 4,
        NCT_TUNNEL = 5,
        NCT_BRIDGE = 6,
    };
    enum class NETISO_ERROR_TYPE : int32_t
    {
        NETISO_ERROR_TYPE_NONE = 0,
        NETISO_ERROR_TYPE_PRIVATE_NETWORK = 1,
        NETISO_ERROR_TYPE_INTERNET_CLIENT = 2,
        NETISO_ERROR_TYPE_INTERNET_CLIENT_SERVER = 3,
        NETISO_ERROR_TYPE_MAX = 4,
    };
    enum class NETISO_FLAG : int32_t
    {
        NETISO_FLAG_FORCE_COMPUTE_BINARIES = 1,
        NETISO_FLAG_MAX = 2,
    };
    enum class NET_FW_ACTION : int32_t
    {
        NET_FW_ACTION_BLOCK = 0,
        NET_FW_ACTION_ALLOW = 1,
        NET_FW_ACTION_MAX = 2,
    };
    enum class NET_FW_AUTHENTICATE_TYPE : int32_t
    {
        NET_FW_AUTHENTICATE_NONE = 0,
        NET_FW_AUTHENTICATE_NO_ENCAPSULATION = 1,
        NET_FW_AUTHENTICATE_WITH_INTEGRITY = 2,
        NET_FW_AUTHENTICATE_AND_NEGOTIATE_ENCRYPTION = 3,
        NET_FW_AUTHENTICATE_AND_ENCRYPT = 4,
    };
    enum class NET_FW_EDGE_TRAVERSAL_TYPE : int32_t
    {
        NET_FW_EDGE_TRAVERSAL_TYPE_DENY = 0,
        NET_FW_EDGE_TRAVERSAL_TYPE_ALLOW = 1,
        NET_FW_EDGE_TRAVERSAL_TYPE_DEFER_TO_APP = 2,
        NET_FW_EDGE_TRAVERSAL_TYPE_DEFER_TO_USER = 3,
    };
    enum class NET_FW_IP_PROTOCOL : int32_t
    {
        NET_FW_IP_PROTOCOL_TCP = 6,
        NET_FW_IP_PROTOCOL_UDP = 17,
        NET_FW_IP_PROTOCOL_ANY = 256,
    };
    enum class NET_FW_IP_VERSION : int32_t
    {
        NET_FW_IP_VERSION_V4 = 0,
        NET_FW_IP_VERSION_V6 = 1,
        NET_FW_IP_VERSION_ANY = 2,
        NET_FW_IP_VERSION_MAX = 3,
    };
    enum class NET_FW_MODIFY_STATE : int32_t
    {
        NET_FW_MODIFY_STATE_OK = 0,
        NET_FW_MODIFY_STATE_GP_OVERRIDE = 1,
        NET_FW_MODIFY_STATE_INBOUND_BLOCKED = 2,
    };
    enum class NET_FW_POLICY_TYPE : int32_t
    {
        NET_FW_POLICY_GROUP = 0,
        NET_FW_POLICY_LOCAL = 1,
        NET_FW_POLICY_EFFECTIVE = 2,
        NET_FW_POLICY_TYPE_MAX = 3,
    };
    enum class NET_FW_PROFILE_TYPE : int32_t
    {
        NET_FW_PROFILE_DOMAIN = 0,
        NET_FW_PROFILE_STANDARD = 1,
        NET_FW_PROFILE_CURRENT = 2,
        NET_FW_PROFILE_TYPE_MAX = 3,
    };
    enum class NET_FW_PROFILE_TYPE2 : int32_t
    {
        NET_FW_PROFILE2_DOMAIN = 1,
        NET_FW_PROFILE2_PRIVATE = 2,
        NET_FW_PROFILE2_PUBLIC = 4,
        NET_FW_PROFILE2_ALL = 2147483647,
    };
    enum class NET_FW_RULE_CATEGORY : int32_t
    {
        NET_FW_RULE_CATEGORY_BOOT = 0,
        NET_FW_RULE_CATEGORY_STEALTH = 1,
        NET_FW_RULE_CATEGORY_FIREWALL = 2,
        NET_FW_RULE_CATEGORY_CONSEC = 3,
        NET_FW_RULE_CATEGORY_MAX = 4,
    };
    enum class NET_FW_RULE_DIRECTION : int32_t
    {
        NET_FW_RULE_DIR_IN = 1,
        NET_FW_RULE_DIR_OUT = 2,
        NET_FW_RULE_DIR_MAX = 3,
    };
    enum class NET_FW_SCOPE : int32_t
    {
        NET_FW_SCOPE_ALL = 0,
        NET_FW_SCOPE_LOCAL_SUBNET = 1,
        NET_FW_SCOPE_CUSTOM = 2,
        NET_FW_SCOPE_MAX = 3,
    };
    enum class NET_FW_SERVICE_TYPE : int32_t
    {
        NET_FW_SERVICE_FILE_AND_PRINT = 0,
        NET_FW_SERVICE_UPNP = 1,
        NET_FW_SERVICE_REMOTE_DESKTOP = 2,
        NET_FW_SERVICE_NONE = 3,
        NET_FW_SERVICE_TYPE_MAX = 4,
    };
    enum class SHARINGCONNECTIONTYPE : int32_t
    {
        ICSSHARINGTYPE_PUBLIC = 0,
        ICSSHARINGTYPE_PRIVATE = 1,
    };
    enum class SHARINGCONNECTION_ENUM_FLAGS : int32_t
    {
        ICSSC_DEFAULT = 0,
        ICSSC_ENABLED = 1,
    };
    enum class _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS : int32_t
    {
        FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_AUTO_RESOLVE = 1,
        FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_NON_AUTO_RESOLVE = 2,
        FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_ALL = 3,
    };
    enum class _tag_FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS : int32_t
    {
        FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS_AUTO_RESOLVE = 1,
    };
    enum class _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE : int32_t
    {
        FW_DYNAMIC_KEYWORD_ORIGIN_INVALID = 0,
        FW_DYNAMIC_KEYWORD_ORIGIN_LOCAL = 1,
        FW_DYNAMIC_KEYWORD_ORIGIN_MDM = 2,
    };
#pragma endregion enums

#pragma region forward_declarations
    struct INET_FIREWALL_AC_BINARIES;
    struct INET_FIREWALL_AC_CAPABILITIES;
    struct INET_FIREWALL_AC_CHANGE;
    struct INET_FIREWALL_APP_CONTAINER;
    struct NETCON_PROPERTIES;
    struct NetFwAuthorizedApplication;
    struct NetFwMgr;
    struct NetFwOpenPort;
    struct NetFwPolicy2;
    struct NetFwProduct;
    struct NetFwProducts;
    struct NetFwRule;
    struct NetSharingManager;
    struct UPnPNAT;
    struct _tag_FW_DYNAMIC_KEYWORD_ADDRESS0;
    struct _tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0;
    struct IDynamicPortMapping;
    struct IDynamicPortMappingCollection;
    struct IEnumNetConnection;
    struct IEnumNetSharingEveryConnection;
    struct IEnumNetSharingPortMapping;
    struct IEnumNetSharingPrivateConnection;
    struct IEnumNetSharingPublicConnection;
    struct INATEventManager;
    struct INATExternalIPAddressCallback;
    struct INATNumberOfEntriesCallback;
    struct INetConnection;
    struct INetConnectionConnectUi;
    struct INetConnectionManager;
    struct INetConnectionProps;
    struct INetFwAuthorizedApplication;
    struct INetFwAuthorizedApplications;
    struct INetFwIcmpSettings;
    struct INetFwMgr;
    struct INetFwOpenPort;
    struct INetFwOpenPorts;
    struct INetFwPolicy;
    struct INetFwPolicy2;
    struct INetFwProduct;
    struct INetFwProducts;
    struct INetFwProfile;
    struct INetFwRemoteAdminSettings;
    struct INetFwRule;
    struct INetFwRule2;
    struct INetFwRule3;
    struct INetFwRules;
    struct INetFwService;
    struct INetFwServiceRestriction;
    struct INetFwServices;
    struct INetSharingConfiguration;
    struct INetSharingEveryConnectionCollection;
    struct INetSharingManager;
    struct INetSharingPortMapping;
    struct INetSharingPortMappingCollection;
    struct INetSharingPortMappingProps;
    struct INetSharingPrivateConnectionCollection;
    struct INetSharingPublicConnectionCollection;
    struct IStaticPortMapping;
    struct IStaticPortMappingCollection;
    struct IUPnPNAT;
#pragma endregion forward_declarations

#pragma region delegates
    using PAC_CHANGES_CALLBACK_FN = void __stdcall(void*, Windows::Win32::NetworkManagement::WindowsFirewall::INET_FIREWALL_AC_CHANGE*);
    using PNETISO_EDP_ID_CALLBACK_FN = void __stdcall(void*, Windows::Win32::Foundation::PWSTR, uint32_t);
    using PFN_FWADDDYNAMICKEYWORDADDRESS0 = uint32_t __stdcall(Windows::Win32::NetworkManagement::WindowsFirewall::_tag_FW_DYNAMIC_KEYWORD_ADDRESS0*);
    using PFN_FWDELETEDYNAMICKEYWORDADDRESS0 = uint32_t __stdcall(::win32::guid);
    using PFN_FWENUMDYNAMICKEYWORDADDRESSESBYTYPE0 = uint32_t __stdcall(uint32_t, Windows::Win32::NetworkManagement::WindowsFirewall::_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0**);
    using PFN_FWENUMDYNAMICKEYWORDADDRESSBYID0 = uint32_t __stdcall(::win32::guid, Windows::Win32::NetworkManagement::WindowsFirewall::_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0**);
    using PFN_FWFREEDYNAMICKEYWORDADDRESSDATA0 = uint32_t __stdcall(Windows::Win32::NetworkManagement::WindowsFirewall::_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0*);
    using PFN_FWUPDATEDYNAMICKEYWORDADDRESS0 = uint32_t __stdcall(::win32::guid, Windows::Win32::Foundation::PWSTR, Windows::Win32::Foundation::BOOL);
#pragma endregion delegates

}
namespace win32::_impl_
{
#pragma region guids
#pragma endregion guids

}
#endif
